<script>

// Mini Neural Network in JS (for digit recognition)
// Inspired by the book: Make Your Own Neural Network by Tariq Rashid

// Inverse sigmoid activation function
activation_function = a => {
  for(i in a){
    for(j in a[i]){
      a[i][j] = 1/(1+Math.exp(-a[i][j]));
    }
  }
  return a;
}

// Regular matrix multiplication
// a = [[1, 2]], b = [[3], [4]] => r = [[3, 8], [
dot = (a, b, r) => {
  //console.clear();
  console.log(a, b);
  r = Array.from(Array(a[0].length), () => new Array(b.length).fill(0));
  //console.log(r);
  for(i in r){
    for(j in r[i]){ 
      for(k = 0; k < a.length; k++){
        console.log(+i,+j,k);
        console.log("aik",a[k][j]);
        console.log("bkj",b[i][k]);
        r[i][j] += a[k][j]*b[i][k];
        console.log("rij",r[i][j]);
      }
    }
  }
  return r;
}

// Term by term matrix multiplication
mul = (a, b, r) => {
  r = Array.from(Array(a.length), () => new Array(a[0].length).fill(0));
  for(i in r){
    for(j in r[i]){
      r[i][j] = a[i][j] * b[i][j];
    }
  }
  return r;
}

// Term by term matrix subtraction
sub = (a, b, r) => {
  r = Array.from(Array(a.length), () => new Array(a[0].length).fill(0));
  for(i in r){
    for(j in r[i]){
      r[i][j] = a[i][j] - b[i][j];
    }
  }
  return r;
}

// Term by term matrix addition
add = (a, b, r) => {
  r = Array.from(Array(a.length), () => new Array(a[0].length).fill(0));
  for(i in r){
    for(j in r[i]){
      r[i][j] = a[i][j] + b[i][j];
    }
  }
  return r;
}

// Term by term complement in a matrix (n => 1-n)
complement = a => {
  r = Array.from(Array(a.length), () => new Array(a[0].length).fill(0));
  for(i in a){
    for(j in a[i]){
      a[i][j] = 1 - a[i][j];
    }
  }
  return a;
}

// Transpose a matrix
transpose = (a, r) => {
  r = Array.from(Array(a[0].length), () => new Array(a.length).fill(0));
  for(i in r){
    for(j in r[i]){
      r[i][j] = a[j][i];
    }
  }
  return r;
}

// Neural Network
class nn {

  // Init
  constructor(inputnodes, hiddennodes, outputnodes, learningrate){
    this.inodes = inputnodes;
    this.hnodes = hiddennodes;
    this.onodes = outputnodes;
    this.lr = learningrate;
    
    // weights from input to hidden (random)
    this.wih = Array.from(Array(this.hnodes), () => new Array(this.inodes).fill(Math.random()-.5));
    
    // weights from hidden to output (random)
    this.who = Array.from(Array(this.onodes), () => new Array(this.hnodes).fill(Math.random()-.5));
  }
  
  // Train
  train(inputs_list, targets_list){
  
    // convert inputs list and target list to a flat matrix [[n1, n2, ...]]
    var inputs = transpose([inputs_list]);
    console.clear();
    console.log(inputs); // 2x1
    
    var targets = transpose([targets_list]);
    console.log(targets); // 1x1
    
    // calculate signals into hidden layer
    var hidden_inputs = dot(this.wih, inputs);
    console.log(hidden_inputs); // 2x2
    
    // calculate the signals emerging from hidden layer
    var hidden_outputs = activation_function(hidden_inputs);
    console.log(hidden_outputs); // 2x2
    
    // calculate signals into final output layer
    var final_inputs = dot(this.who, hidden_outputs);
    console.log(hidden_outputs); // 2x2
    
    // calculate the signals emerging from final output layer
    var final_outputs = activation_function(final_inputs);
    
    //console.log(final_outputs);
    
    // output layer error is (target - actual)
    var output_errors = sub(targets, final_outputs);
    
    // hidden layer error is the output_errors, split by weights, recombined at hidden nodes
    var hidden_errors = dot(transpose(this.who), output_errors);
    
    // update the weights for the links between the hidden and output layers
    var r4 = mul(output_errors, final_outputs);
    console.log(r4);
    var r3 = mul(r4, complement(final_outputs));
    console.log(r3, hidden_outputs);
    var r2 = dot(r3, transpose(hidden_outputs));
    console.log(r2);
    var r1 = mul(this.lr, r2);
    console.log(r1);
    this.who = add(this.who, r1);
    
    // update the weights for the links between the input and hidden layers
    this.wih = add(this.wih, mul(this.lr, dot((mul(mul(hidden_errors, hidden_outputs), complement(hidden_outputs))), transpose(inputs))));
  }
  
  // Query
  query(inputs_list){
    
    // convert inputs list to 2d array
    var inputs = transpose([inputs_list]);
    
    // calculate signals into hidden layer
    var hidden_inputs = dot(this.wih, inputs);
    
    // calculate the signals emerging from hidden layer
    var hidden_outputs = activation_function(hidden_inputs);
    
    // calculate signals into final output layer
    console.log(this.who, hidden_inputs, hidden_outputs)
    var final_inputs = dot(this.who, hidden_outputs);
    
    // calculate the signals emerging from final output layer
    var final_outputs = activation_function(final_inputs);
    
    return final_outputs;
  }
}

n = new nn(2,1);

console.log("Before training...");
console.log('0 AND 0',n.query([0,0]));
console.log('0 AND 1',n.query([0,1]));
console.log('1 AND 0',n.query([1,0]));
console.log('1 AND 1',n.query([1,1]));

training_data = [
  [[1,1], [1]],
  [[1,0], [0]],
  [[0,1], [0]],
  [[0,0], [0]],
];

// several training epochs
for(i = 0; i < 10; i++){
  tdata = training_data[Math.floor(Math.random() * training_data.length)];
  n.train(tdata[0], tdata[1]);
}

console.log("After training...");
console.log('0 AND 0',n.query([0,0]));
console.log('0 AND 1',n.query([0,1]));
console.log('1 AND 0',n.query([1,0]));
console.log('1 AND 1',n.query([1,1]));


</script>