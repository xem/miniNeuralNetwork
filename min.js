f=t=>1/(1+Math.exp(-t)),g=t=>t*(1-t),l=.2;class t{constructor(t,s){this.rows=t,this.cols=s,this.data=Array(this.rows).fill().map((()=>Array(this.cols).fill(0)))}copy(){let s=new t(this.rows,this.cols);for(let t=0;t<this.rows;t++)for(let o=0;o<this.cols;o++)s.data[t][o]=this.data[t][o];return s}static fromArray(s){return new t(s.length,1).map(((t,o)=>s[o]))}static subtract(s,o){if(s.rows===o.rows&&s.cols===o.cols)return new t(s.rows,s.cols).map(((t,i,a)=>s.data[i][a]-o.data[i][a]));console.log("Columns and Rows of A must match Columns and Rows of B.")}toArray(){let t=[];for(let s=0;s<this.rows;s++)for(let o=0;o<this.cols;o++)t.push(this.data[s][o]);return t}randomize(){return this.map((t=>2*Math.random()-1))}add(s){return s instanceof t?this.rows!==s.rows||this.cols!==s.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map(((t,o,i)=>t+s.data[o][i])):this.map((t=>t+s))}static transpose(s){return new t(s.cols,s.rows).map(((t,o,i)=>s.data[i][o]))}static multiply(s,o){if(s.cols===o.rows)return new t(s.rows,o.cols).map(((t,i,a)=>{let r=0;for(let t=0;t<s.cols;t++)r+=s.data[i][t]*o.data[t][a];return r}));console.log("Columns of A must match rows of B.")}multiply(s){return s instanceof t?this.rows!==s.rows||this.cols!==s.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map(((t,o,i)=>t*s.data[o][i])):this.map((t=>t*s))}map(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.cols;o++){let i=this.data[s][o];this.data[s][o]=t(i,s,o)}return this}static map(s,o){return new t(s.rows,s.cols).map(((t,i,a)=>o(s.data[i][a],i,a)))}}class NeuralNetwork{constructor(s,o,i){this.input_nodes=s,this.hidden_nodes=o,this.output_nodes=i,this.weights_ih=new t(this.hidden_nodes,this.input_nodes),this.weights_ho=new t(this.output_nodes,this.hidden_nodes),this.weights_ih.randomize(),this.weights_ho.randomize()}predict(s){let o=t.fromArray(s),i=t.multiply(this.weights_ih,o);i.map(f);let a=t.multiply(this.weights_ho,i);return a.map(f),a.toArray()}train(s,o){let i=t.fromArray(s),a=t.multiply(this.weights_ih,i);a.map(f);let r=t.multiply(this.weights_ho,a);r.map(f);let l=t.fromArray(o),e=t.subtract(l,r),h=t.map(r,g);h.multiply(e),h.multiply(.2);let n=t.transpose(a),m=t.multiply(h,n);this.weights_ho.add(m);let u=t.transpose(this.weights_ho),d=t.multiply(u,e),w=t.map(a,g);w.multiply(d),w.multiply(.2);let p=t.transpose(i),c=t.multiply(w,p);this.weights_ih.add(c)}}


// Customization
// =============

// Learning rate
l = 0.2;

// Activation function (sigmoid)
f = x => 1 / (1 + Math.E ** -x);

// Gradient descent function
g = x => x * (1 - x);