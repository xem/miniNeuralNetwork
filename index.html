<script>

// Create matrix
// - filled with random numbers by default
// - filled with zero if z = 1
M = (r, c, z) => Array(r).fill().map(() => Array(c).fill(z ? 0 : Math.random() * 2 - 1));


class Matrix {
  constructor(r, c) {
    this.data = Array(r).fill().map(() => Array(c).fill(Math.random() * 2 - 1));
  }

  static fromArray(arr) {
    return new Matrix(arr.length, 1).map((e, i) => arr[i]);
  }

  static S(a, b) {
    return new Matrix(a.data.length, a.data[0].length)
      .map((_, i, j) => a.data[i][j] - b.data[i][j]);
  }

  A(n) {
    return this.map((e, i, j) => e + n.data[i][j]);
  }

  static T(matrix) {
    return new Matrix(matrix.data[0].length, matrix.data.length)
      .map((_, i, j) => matrix.data[j][i]);
  }

  static D(a, b) {
    return new Matrix(a.data.length, b.data[0].length)
      .map((e, i, j, k, sum) => {
        // Dot product of values in col
        sum = 0;
        for(k = 0; k < a.data[0].length; k++) {
          sum += a.data[i][k] * b.data[k][j];
        }
        return sum;
      });
  }

  P(n) {
    return this.map((e, i, j) => e * n.data[i][j]);
  }
  
  S(n) {
    return this.map(e => e * n);
  }

  map(func, i, j, val) {
    // Apply a function to every element of matrix
    for(i = 0; i < this.data.length; i++) {
      for(j = 0; j < this.data[0].length; j++) {
        val = this.data[i][j];
        this.data[i][j] = func(val, i, j);
      }
    }
    return this;
  }

  static map(matrix, func) {
    // Apply a function to every element of matrix
    return new Matrix(matrix.data.length, matrix.data[0].length)
      .map((e, i, j) => func(matrix.data[i][j], i, j));
  }
}

// Mini Neural Network
N = {

  // Params:
  // - i: input nodes
  // - h: hidden nodes
  // - o: output nodes
  // - l: learning rate
  // - f: activation function (default sigmoid)
  // - g: gradient descent function (default: y*(1-y))
  
  init: (i, h, o, l = 0.1, f = (x => 1 / (1 + Math.exp(-x))), g = (y => y * (1 - y))) => {
    N.l = l;
    N.f = f;
    N.g = g;

    // Generate random weights from input to hidden, and from hidden to output
    N.wih = new Matrix(h, i);
    N.who = new Matrix(o, h);

    // Generate random bias for hidden and output
    N.bh = new Matrix(h, 1);
    N.bo = new Matrix(o, 1);
  },

  query: (input_array, h, o) => {

    // Generate hidden nodes outputs
    h = Matrix.D(N.wih, Matrix.fromArray(input_array));
    h.A(N.bh);
    
    // activation function
    h.map(N.f);

    // Generate output nodes outputs
    o = Matrix.D(N.who, h);
    o.A(N.bo);
    o.map(N.f);

    return o.data;
  },

  train: (input_array, target_array, i, h, o, oe, og, hg) => {
  
    ///// same as query() but i is reused later /////
    
    // Generate hidden nodes outputs
    i = Matrix.fromArray(input_array);
    h = Matrix.D(N.wih, i);
    h.A(N.bh);
    
    // activation function
    h.map(N.f);

    // Generating output nodes output
    o = Matrix.D(N.who, h);
    o.A(N.bo);
    o.map(N.f);
    
    //////////////////////////////////////////////////

    // Calculate the output nodes error (target - output)
    oe = Matrix.S(Matrix.fromArray(target_array), o);

    // Calculate output nodes gradient
    og = Matrix.map(o, N.g).P(oe).S(N.l);

    // Adjust hidden to output weights with deltas (output gradient x Td hidden nodes)
    N.who.A(Matrix.D(og, Matrix.T(h)));
    
    // Adjust bias with gradients
    N.bo.A(og);

    // Calculate hidden gradient, apply the hidden layer errors (Td hidden to output weights x output nodes errors)
    hg = Matrix.map(h, N.g).P(Matrix.D(Matrix.T(N.who), oe)).S(N.l)

    // Adjust input to hidden weights with deltas (hidden gradient x Td input)
    N.wih.A(Matrix.D(hg, Matrix.T(i)));
    
    // Adjust the bias with gradients
    N.bh.A(hg);
  }
}

N.init(2,3,1);

console.log("Before training...");
console.log('0 AND 0',N.query([0,0])[0]);
console.log('0 AND 1',N.query([0,1])[0]);
console.log('1 AND 0',N.query([1,0])[0]);
console.log('1 AND 1',N.query([1,1])[0]);

training_data = [
  [[1,1], [1]],
  [[1,0], [0]],
  [[0,1], [0]],
  [[0,0], [0]],
];

// several training epochs
for(i = 0; i < 10000; i++){
  tdata = training_data[Math.floor(Math.random() * training_data.length)];
  N.train(tdata[0], tdata[1]);
}

console.log("After training...");
console.log('0 AND 0',N.query([0,0])[0]);
console.log('0 AND 1',N.query([0,1])[0]);
console.log('1 AND 0',N.query([1,0])[0]);
console.log('1 AND 1',N.query([1,1])[0]);


</script>