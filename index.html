<script>

// Create matrix
// - filled with random numbers by default
// - filled with zero if z = 1
M = (r, c, z) => Array(r).fill().map(() => Array(c).fill(z ? 0 : Math.random()));

// Matrix dot product
D = (A, B) => {
  return A.map((row, i) =>
    B[0].map((_, j) =>
      row.reduce((acc, _, n) =>
        acc + A[i][n] * B[n][j], 0
      )
    )
  )
};

// Columnize an array ([a,b] => [[a],[b]]
C = (a,r) => {
  r = [];
  a.map(z=>r.push([z]));
  return r;
};

// Add matrices (a += b)
A = (a, b, i, j) => {
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      a[i][j] += b[i][j];
    }
  }
}

// Subtract matrices (r = a - b)
S = (a, b, r, i, j) => {
  r = M(a.length, a[0].length, 1);
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      r[i][j] = a[i][j] - b[i][j];
    }
  }
  return r;
}

// Product of two matrices (r = a * b, term by term)
P = (a, b, r, i, j) => {
  r = M(a.length, a[0].length, 1);
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      r[i][j] = a[i][j] * b[i][j];
    }
  }
  return r;
}

// Map a function to a matrix
F = (a, f, i, j) => {
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      a[i][j] = f(a[i][j]);
    }
  }
}

// Resize a matrix (r = a * s)
R = (a, s, r, i, j) => {
  r = M(a.length, a[0].length, 1);
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      r[i][j] = s * a[i][j];
    }
  }
  return r;
}

// Transpose a matrix
T = (a, r, i, j) => {
  r = M(a[0].length, a.length, 1);
  for(i = 0; i < a.length; i++){
    for(j = 0; j < a[0].length; j++){
      r[j][i] = a[i][j];
    }
  }
  return r;
}

// Mini Neural Network
N = {

  // Init
  
  // Params:
  // - i: input nodes
  // - h: hidden nodes
  // - o: output nodes
  // - l: learning rate
  // - f: activation function (default: sigmoid)
  // - g: gradient descent function (default: y*(1-y))
  
  i: (i, h, o, l = 0.1, f = (x => 1 / (1 + Math.exp(-x))), g = (y => y * (1 - y))) => {
    N.l = l;
    N.f = f;
    N.g = g;

    // Generate random weights from input to hidden, and from hidden to output
    N.wih = M(h, i); 
    N.who = M(o, h);

    // Generate random bias for hidden and output
    N.bh = M(h, 1);
    N.bo = M(o, 1);
  },

  // Passthrough function
  // Used for both training and querying the network
  
  // Params: 
  // - input: input nodes
  // - target: desired output (for training) / undefined (for querying)
  p: (input, target, i, h, o, oe, og, hg) => {
  
    // Generate hidden nodes's outputs
    i = C(input);
    h = D(N.wih, i);
    A(h, N.bh);
    
    // activation function
    F(h, N.f);

    // Generating output nodes's output
    o = D(N.who, h);
    A(o, N.bo);
    F(o, N.f);
    
    if(!target) return o;

    // Calculate the output nodes error (target - output)
    oe = S(C(target), o);

    // Calculate output nodes gradient
    F(o, N.g);
    og = R(P(o, oe), N.l);

    // Adjust hidden to output weights with deltas (output gradient x transposed hidden nodes)
    A(N.who, D(og, T(h)));
    
    // Adjust bias with gradients
    A(N.bo, og); 

    // Calculate hidden gradient, apply the hidden layer errors (Td hidden to output weights x output nodes errors)
    F(h, N.g);
    hg = R(P(h, D(T(N.who), oe)), N.l);

    // Adjust input to hidden weights with deltas (hidden gradient x transposed input)
    A(N.wih, D(hg, T(i)));
    
    // Adjust the bias with gradients
    A(N.bh,hg);
  }
}

N.i(2,3,1);

console.log("Before training...");
console.log('0 AND 0',N.p([0,0])[0]);
console.log('0 AND 1',N.p([0,1])[0]);
console.log('1 AND 0',N.p([1,0])[0]);
console.log('1 AND 1',N.p([1,1])[0]);

training_data = [
  [[1,1], [1]],
  [[1,0], [0]],
  [[0,1], [0]],
  [[0,0], [0]],
];

// several training epochs
for(i = 0; i < 10000; i++){
  tdata = training_data[Math.floor(Math.random() * training_data.length)];
  N.p(tdata[0], tdata[1]);
}

console.log("After training...");
console.log('0 AND 0',N.p([0,0])[0]);
console.log('0 AND 1',N.p([0,1])[0]);
console.log('1 AND 0',N.p([1,0])[0]);
console.log('1 AND 1',N.p([1,1])[0]);


</script>