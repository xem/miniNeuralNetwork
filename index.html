<script>
// Helpers
// =======

// Create a matrix:
// - filled with random numbers by default
// - filled with zero if z = 1
M = (r,c=1,z) => Array(r).fill().map(() => Array(c).fill(z ? 0 : Math.random() - 1));

// Operations on matrices:
// o === 0: addition (a+=b) (default)
// o === 1: subtraction (a-=b)
// o === 2: product (a*=b)
// o === 3: scale (a*=b, b is a scalar)
// o === 4: map (a=b(a), b is a function
// o === 6: dot product (r = a.b)
O = (a, b, o, r, i, j, k, l = "length") => {
  if(o === 6) r = M(a[l], b[0][l], 1); // dot product
  for(i = a[l]; i--;){
    for(j = a[0][l]; j--;){
      if(
        o === 6 || (( // dot
          a[i][j] = (
            o === 1 ? a[i][j] - b[i][j] // sub
            : o === 2 ? a[i][j] * b[i][j] // product
            : o === 3 ? a[i][j] * b // scale
            : o === 4 ? b(a[i][j]) // map
            : a[i][j] + b[i][j] // add
          )
        ), 0)
      ){
        for(k = b[0][l]; k--;){
          r[i][k] += a[i][j] * b[j][k]; // dot
        }
      }
    }
  }
  return o === 6 ? r : a;
}

// Customization
// =============

// Learning rate
l = 0.3;

// Activation function (sigmoid)
f = (x => 1 / (1 + Math.E**-x));

// Gradient descent function
g = (y => y * (1 - y));

// Data
// ====

// Weights: W, w
// Bias: B, b

// Mini Neural Network
// ===================

// Init
  
// Params:
// - i: input nodes
// - h: hidden nodes
// - o: output nodes
// - l: learning rate

i = (i, h, o) => {

  // Generate random weights from input nodes to hidden nodes, and from hidden nodes to output nodes
  w = M(h, i); 
  W = M(o, h);

  // Generate random bias for hidden and output nodes
  b = M(h);
  B = M(o);
}

// Passthrough function
// Used for both training and querying the network

// Params: 
// - input: input nodes
// - target: desired output (for training) / undefined (for querying)
p = (input, target, h, o) => {
  
  // Generate hidden nodes' outputs
  // Use activation function
  // Generating output nodes' output
  o = O(O(O(W, O(O(h = O(w, input, 6), b), f, 4), 6), B), f, 4);
  
  // Query code ends here:
  if(!target) return o;

  // Training coninues here:
  // Calculate output nodes' error (target - output)
  O(target, o, 1);

  // Calculate output nodes' gradient
  // Adjust hidden to output weights with deltas (output gradient x transposed hidden nodes)
  O(W, O(o = O(O(O(o, g, 4), target, 2), l, 3), [h.flat()], 6));
  
  // Adjust bias with gradients
  O(B, o); 

  // Calculate hidden gradient, apply the hidden layer errors (transposed hidden to output weights x output nodes errors)
  // Adjust input to hidden weights with deltas (hidden gradient x transposed input)
  O(w, O(h = O(O(O(h, g, 4), O(W[0].map(z=>[z]), target, 6), 2), l, 3), [input.flat()], 6));
  
  // Adjust the bias with gradients
  O(b, h);
}

// Columnize an array ([a,b] => [[a],[b]])
C = a => a.map(z=>[z]);

// Demo
i(2,3,1);

console.log("Before training...");
console.log('0 AND 0',p(C([0,0]))[0][0]);
console.log('0 AND 1',p(C([0,1]))[0][0]);
console.log('1 AND 0',p(C([1,0]))[0][0]);
console.log('1 AND 1',p(C([1,1]))[0][0]);

training_data = [
  [[1,1], [1]],
  [[1,0], [0]],
  [[0,1], [0]],
  [[0,0], [0]],
];

// several training epochs
for(t = 0; t < 50000; t++){
  tdata = training_data[Math.floor(Math.random() * training_data.length)];
  p(C(tdata[0]), C(tdata[1]));
}

console.log("After training...");
console.log('0 AND 0',p(C([0,0]))[0][0]);
console.log('0 AND 1',p(C([0,1]))[0][0]);
console.log('1 AND 0',p(C([1,0]))[0][0]);
console.log('1 AND 1',p(C([1,1]))[0][0]);


// Demo 2
i(2,10,1);

console.log("Before training...");
console.log('0 XOR 0',p(C([0,0]))[0][0]);
console.log('0 XOR 1',p(C([0,1]))[0][0]);
console.log('1 XOR 0',p(C([1,0]))[0][0]);
console.log('1 XOR 1',p(C([1,1]))[0][0]);

training_data2 = [
  [[1,1], [0]],
  [[1,0], [1]],
  [[0,1], [1]],
  [[0,0], [0]],
];

// several training epochs
for(t = 0; t < 50000; t++){
  tdata = training_data2[Math.floor(Math.random() * training_data2.length)];
  p(C(tdata[0]), C(tdata[1]));
}

console.log("After training...");
console.log('0 XOR 0',p(C([0,0]))[0][0]);
console.log('0 XOR 1',p(C([0,1]))[0][0]);
console.log('1 XOR 0',p(C([1,0]))[0][0]);
console.log('1 XOR 1',p(C([1,1]))[0][0]);
</script>