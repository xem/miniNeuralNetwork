<script>

class Matrix {
  constructor(rows, cols) {
    this.rows = rows;
    this.cols = cols;
    this.data = Array(this.rows).fill().map(() => Array(this.cols).fill(Math.random() * 2 - 1));
  }

  static fromArray(arr) {
    return new Matrix(arr.length, 1).map((e, i) => arr[i]);
  }

  static subtract(a, b) {
    if (a.rows !== b.rows || a.cols !== b.cols) {
      console.log('Columns and Rows of A must match Columns and Rows of B.');
      return;
    }

    // Return a new Matrix a-b
    return new Matrix(a.rows, a.cols)
      .map((_, i, j) => a.data[i][j] - b.data[i][j]);
  }

  toArray() {
    let arr = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        arr.push(this.data[i][j]);
      }
    }
    return arr;
  }

  add(n) {
    if (n instanceof Matrix) {
      if (this.rows !== n.rows || this.cols !== n.cols) {
        console.log('Columns and Rows of A must match Columns and Rows of B.');
        return;
      }
      return this.map((e, i, j) => e + n.data[i][j]);
    } else {
      return this.map(e => e + n);
    }
  }

  static transpose(matrix) {
    return new Matrix(matrix.cols, matrix.rows)
      .map((_, i, j) => matrix.data[j][i]);
  }

  static multiply(a, b) {
    // Matrix product
    if (a.cols !== b.rows) {
      console.log('Columns of A must match rows of B.');
      return;
    }

    return new Matrix(a.rows, b.cols)
      .map((e, i, j) => {
        // Dot product of values in col
        let sum = 0;
        for (let k = 0; k < a.cols; k++) {
          sum += a.data[i][k] * b.data[k][j];
        }
        return sum;
      });
  }

  multiply(n) {
    if (n instanceof Matrix) {
      if (this.rows !== n.rows || this.cols !== n.cols) {
        console.log('Columns and Rows of A must match Columns and Rows of B.');
        return;
      }

      // hadamard product
      return this.map((e, i, j) => e * n.data[i][j]);
    } else {
      // Scalar product
      return this.map(e => e * n);
    }
  }

  map(func) {
    // Apply a function to every element of matrix
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        let val = this.data[i][j];
        this.data[i][j] = func(val, i, j);
      }
    }
    return this;
  }

  static map(matrix, func) {
    // Apply a function to every element of matrix
    return new Matrix(matrix.rows, matrix.cols)
      .map((e, i, j) => func(matrix.data[i][j], i, j));
  }
}

// Mini Neural Network
NN = {

  // Params:
  // - i: input nodes
  // - h: hidden nodes
  // - o: output nodes
  // - l: learning rate
  // - f: activation function (default sigmoid)
  // - g: gradient descent function (default: y*(1-y))
  
  init: (i, h, o, l = 0.1, f = (x => 1 / (1 + Math.exp(-x))), g = (y => y * (1 - y))) => {
    NN.l = l;
    NN.f = f;
    NN.g = g;

    // Generate random weights from input to hidden, and from hidden to output
    NN.wih = new Matrix(h, i);
    NN.who = new Matrix(o, h);

    // Generate random bias for hidden and output
    NN.bh = new Matrix(h, 1);
    NN.bo = new Matrix(o, 1);
  },

  query: (input_array, h, o) => {

    // Generate hidden nodes outputs
    h = Matrix.multiply(NN.wih, Matrix.fromArray(input_array));
    h.add(NN.bh);
    
    // activation function
    h.map(NN.f);

    // Generate output nodes outputs
    o = Matrix.multiply(NN.who, h);
    o.add(NN.bo);
    o.map(NN.f);

    return o.toArray();
  },

  train: (input_array, target_array, i, h, o, oe, og, hg) => {
  
    ///// same as query() but i is reused later /////
    
    // Generate hidden nodes outputs
    i = Matrix.fromArray(input_array);
    h = Matrix.multiply(NN.wih, i);
    h.add(NN.bh);
    
    // activation function
    h.map(NN.f);

    // Generating output nodes output
    o = Matrix.multiply(NN.who, h);
    o.add(NN.bo);
    o.map(NN.f);
    
    //////////////////////////////////////////////////

    // Calculate the output nodes error (target - output)
    oe = Matrix.subtract(Matrix.fromArray(target_array), o);

    // Calculate output nodes gradient
    og = Matrix.map(o, NN.g).multiply(oe).multiply(NN.l);

    // Adjust hidden to output weights with deltas (output gradient x transposed hidden nodes)
    NN.who.add(Matrix.multiply(og, Matrix.transpose(h)));
    
    // Adjust bias with gradients
    NN.bo.add(og);

    // Calculate hidden gradient, apply the hidden layer errors (transposed hidden to output weights x output nodes errors)
    hg = Matrix.map(h, NN.g).multiply(Matrix.multiply(Matrix.transpose(NN.who), oe)).multiply(NN.l)

    // Adjust input to hidden weights with deltas (hidden gradient x transposed input)
    NN.wih.add(Matrix.multiply(hg, Matrix.transpose(i)));
    
    // Adjust the bias with gradients
    NN.bh.add(hg);
  }
}

NN.init(2,3,1);

console.log("Before training...");
console.log('0 AND 0',NN.query([0,0]));
console.log('0 AND 1',NN.query([0,1]));
console.log('1 AND 0',NN.query([1,0]));
console.log('1 AND 1',NN.query([1,1]));

training_data = [
  [[1,1], [1]],
  [[1,0], [0]],
  [[0,1], [0]],
  [[0,0], [0]],
];

// several training epochs
for(i = 0; i < 10000; i++){
  tdata = training_data[Math.floor(Math.random() * training_data.length)];
  NN.train(tdata[0], tdata[1]);
}

console.log("After training...");
console.log('0 AND 0',NN.query([0,0]));
console.log('0 AND 1',NN.query([0,1]));
console.log('1 AND 0',NN.query([1,0]));
console.log('1 AND 1',NN.query([1,1]));


</script>